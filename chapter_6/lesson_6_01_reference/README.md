# Reference:

### Table of operator precedence and associativity
This reference table is copied directly from the [LearnCPP, lesson 6.1](https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/)

> The below table is primarily meant to be a reference chart that you can refer back to in the future to resolve any precedence or associativity questions you have. 
> 
> Notes:
> - Precedence level 1 is the highest precedence level, and level 17 is the lowest. Operators with a higher precedence level have their operands grouped first.
> - L->R means left to right associativity.
> - R->L means right to left associativity.
>
> <div class=cpp-table-wrapper><p><p><table class=cpp-table><tbody><tr><th>Prec/Ass<th>Operator<th>Description<th>Pattern<tr><td>1 L->R<td>::<br>::<td>Global scope (unary)<br>Namespace scope (binary)<td>::name<br>class_name::member_name<br><tr><td>2 L->R<td>()<br>()<br>type()<br>type{}<br>[]<br>.<br>-><br>++<br>––<br>typeid<br>const_cast<br>dynamic_cast<br>reinterpret_cast<br>static_cast<br>sizeof…<br>noexcept<br>alignof<td>Parentheses<br>Function call<br>Functional cast<br>List init temporary object (C++11)<br>Array subscript<br>Member access from object<br>Member access from object ptr<br>Post-increment<br>Post-decrement<br>Run-time type information<br>Cast away const<br>Run-time type-checked cast<br>Cast one type to another<br>Compile-time type-checked cast<br>Get parameter pack size<br>Compile-time exception check<br>Get type alignment<td>(expression)<br>function_name(arguments)<br>type(expression)<br>type{expression}<br>pointer[expression]<br>object.member_name<br>object_pointer->member_name<br>lvalue++<br>lvalue––<br>typeid(type) or typeid(expression)<br>const_cast&lt;type>(expression)<br>dynamic_cast&lt;type>(expression)<br>reinterpret_cast&lt;type>(expression)<br>static_cast&lt;type>(expression)<br>sizeof…(expression)<br>noexcept(expression)<br>alignof(type)<tr><td>3 R->L<td>+<br>-<br>++<br>––<br>!<br>not<br>~<br>(type)<br>sizeof<br>co_await<br>&<br>*<br>new<br>new[]<br>delete<br>delete[]<td>Unary plus<br>Unary minus<br>Pre-increment<br>Pre-decrement<br>Logical NOT<br>Logical NOT<br>Bitwise NOT<br>C-style cast<br>Size in bytes<br>Await asynchronous call<br>Address of<br>Dereference<br>Dynamic memory allocation<br>Dynamic array allocation<br>Dynamic memory deletion<br>Dynamic array deletion<td>+expression<br>-expression<br>++lvalue<br>––lvalue<br>!expression<br>not expression<br>~expression<br>(new_type)expression<br>sizeof(type) or sizeof(expression)<br>co_await expression (C++20)<br>&amp;lvalue<br>*expression<br>new type<br>new type[expression]<br>delete pointer<br>delete[] pointer<tr><td>4 L->R<td>->*<br>.*<td>Member pointer selector<br>Member object selector<td>object_pointer->*pointer_to_member<br>object.*pointer_to_member<tr><td>5 L->R<td>*<br>/<br>%<td>Multiplication<br>Division<br>Remainder<td>expression * expression<br>expression / expression<br>expression % expression<tr><td>6 L->R<td>+<br>-<td>Addition<br>Subtraction<td>expression + expression<br>expression - expression<tr><td>7 L->R<td>&lt;&lt;<br>>><td>Bitwise shift left / Insertion<br>Bitwise shift right / Extraction<td>expression &lt;&lt; expression<br>expression >> expression<tr><td>8 L->R<td>&lt;=><td>Three-way comparison (C++20)<td>expression &lt;=> expression<tr><td>9 L->R<td>&lt;<br>&lt;=<br>><br>>=<td>Comparison less than<br>Comparison less than or equals<br>Comparison greater than<br>Comparison greater than or equals<td>expression &lt; expression<br>expression &lt;= expression<br>expression > expression<br>expression >= expression<tr><td>10 L->R<td>==<br>!=<td>Equality<br>Inequality<td>expression == expression<br>expression != expression<tr><td>11 L->R<td>&<td>Bitwise AND<td>expression & expression<tr><td>12 L->R<td>^<td>Bitwise XOR<td>expression ^ expression<tr><td>13 L->R<td>|<td>Bitwise OR<td>expression | expression<tr><td>14 L->R<td>&&<br>and<td>Logical AND<br>Logical AND<td>expression && expression<br>expression and expression<p><tr><td>15 L->R<td>||<br>or<td>Logical OR<br>Logical OR<td>expression || expression<br>expression or expression<tr><td>16 R->L<td>throw<br>co_yield<br>?:<br>=<br>*=<br>/=<br>%=<br>+=<br>-=<br>&lt;&lt;=<br>>>=<br>&=<br>|=<br>^=<td>Throw expression<br>Yield expression (C++20)<br>Conditional<br>Assignment<br>Multiplication assignment<br>Division assignment<br>Remainder assignment<br>Addition assignment<br>Subtraction assignment<br>Bitwise shift left assignment<br>Bitwise shift right assignment<br>Bitwise AND assignment<br>Bitwise OR assignment<br>Bitwise XOR assignment<td>throw expression<br>co_yield expression<br>expression ? expression : expression<br>lvalue = expression<br>lvalue *= expression<br>lvalue /= expression<br>lvalue %= expression<br>lvalue += expression<br>lvalue -= expression<br>lvalue &lt;&lt;= expression<br>lvalue >>= expression<br>lvalue &= expression<br>lvalue |= expression<br>lvalue ^= expression<tr><td>17 L->R<td>,<td>Comma operator<td>expression, expression</table></div>
